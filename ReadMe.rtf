{\rtf1\ansi\ansicpg1252\cocoartf905
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural

\f0\b\fs24 \cf0 Read Me for ATSUICurveAccessDemo
\b0 \
\
This sample code demonstrates low-level ATSUI APIs which allow access to raw glyph curve data. This sample has been tested and works correctly only on Mac OS X release 10.5 or later. The meat of the example is in the files atsui.c, cubic.c, and quadratic.c.  This example has been updated and coverted to be 64 bit compliant, which means there is no reference to Quickdraw APIs at all.\
\
\'95 Text drawn in black is from a standard ATSUDrawText call.\
\'95 Text outlined in blue is drawn using the cubic outlines.\
\'95 Text outlined in red is drawn using the quadratic outlines.\
\
By default, glyph outlines are drawn using built-in CoreGraphics routines for handling cubic and quadratic curves. \
\
\CocoaLigature0 Many glyphs contain lines of zero length. These are called "degenerate contours", and they are not usually meant to be drawn. Their purpose in most cases is to indicate special parts of the glyph, such as attachment points. Using the drawing code in this program, these will normally show up as dots. However, the conditionals that have comments marking them as a "degenerate filter" are meant to filter out these zero-length segments. The conditionals are triggered by the global flag "gFilterDegenerates", which is toggled via the "Filter Degenerate Cases" menu item. The ATSUI documentation has an example very similar to the code in this program, but it leaves out the degenerate filter for purposes of brevity.}